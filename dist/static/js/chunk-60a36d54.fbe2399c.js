(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-60a36d54"],{bfe5:function(e,t,n){"use strict";n("caff")},caff:function(e,t,n){},f3c5:function(e,t,n){"use strict";n.r(t);var i=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},r=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"container"},[n("div",{attrs:{id:"cesiumContainer"}})])}],a=n("a43d"),m=n("c15f"),o=n("a35b"),s=function(){function e(t,n){Object(m["a"])(this,e),this.Cesium=t,this.viewer=n}return Object(o["a"])(e,[{key:"createParticleSystem",value:function(e){var t=this.Cesium,n=new t.Cartesian3,i={applyGravity:function(i,r){var a=i.position;t.Cartesian3.normalize(a,n);t.Cartesian3.multiplyByScalar(n,e.updateCallback.dt*r,n),i.velocity=t.Cartesian3.add(i.velocity,n,i.velocity)},computeModelMatrix:function(e,n){return e.computeModelMatrix(n,new t.Matrix4)},computeEmitterModelMatrix:function(){var e=new t.Matrix4,n=new t.Cartesian3,i=new t.Quaternion,r=new t.HeadingPitchRoll,a=new t.TranslationRotationScale;return r=t.HeadingPitchRoll.fromDegrees(110,30,0,r),a.translation=t.Cartesian3.fromElements(0,0,1,n),a.rotation=t.Quaternion.fromHeadingPitchRoll(r,i),t.Matrix4.fromTranslationRotationScale(a,e)}},r=this.viewer.scene.primitives.add(new t.ParticleSystem({show:e.show||!0,updateCallback:function(t,n){e.updateCallback(t,n)},emitter:e.emitter||new t.CircleEmitter(.5),modelMatrix:e.modelMatrix||i.computeModelMatrix(e.entity,t.JulianDate.now()),emitterModelMatrix:e.emitterModelMatrix||i.computeEmitterModelMatrix(),emissionRate:e.emissionRate||5,bursts:e.bursts||void 0,loop:e.loop||!0,scale:e.scale||void 0,startScale:e.startScale||void 0,endScale:e.endScale||void 0,color:e.color||t.Color.WHITE,startColor:e.startColor||void 0,endColor:e.endColor||void 0,image:e.image||void 0,imageSize:e.imageSize||new t.Cartesian2(1,1),minimumLife:e.minimumLife||void 0,maximumLife:e.maximumLife||void 0,sizeInMeters:e.sizeInMeters||void 0,speed:e.speed||1,minimumSpeed:e.minimumSpeed||void 0,maximumSpeed:e.maximumSpeed||void 0,lifetime:e.lifetime||.5,particleLife:e.particleLife||5,mass:e.mass||1,minimumMass:e.minimumMass||void 0,maximumMass:e.maximumMass||void 0}));return r}}]),e}(),l=s,c=n("9e48"),u=[{codeLanguage:"VUE",relyOn:[{label:"Primitives.js",url:"cesium/Primitives.js"},{label:"Entity.js",url:"cesium/Entity.js"},{label:"Cesium_Air.glb",url:"Vue/Primitives/ParticleSystem/AircraftTailFlame/Cesium_Air.glb"},{label:"fire.png",url:"Vue/Primitives/ParticleSystem/AircraftTailFlame/fire.png"}],code:[{codeLanguage:"html",content:'<div class="container">\n                    <div id="cesiumContainer"></div>\n                  </div>'},{codeLanguage:"js",content:'import Primitives from "@/common/cesium/Primitives.js";\n                  import Entity from "@/common/cesium/Entity.js";\n                  export default {\n                    name: "AircraftTailFlame",\n                    data() {\n                      return {\n                        viewer: null,\n                        _Primitives: null,\n                        _Entity: null,\n                      };\n                    },\n                    mounted() {\n                      this.init();\n                    },\n                    methods: {\n                      init() {\n                        const Cesium = this.cesium;\n                        Cesium.Ion.defaultAccessToken = process.env.VUE_APP_TOKEN;\n                        this.viewer = new Cesium.Viewer("cesiumContainer", {\n                          imageryProvider: new Cesium.ArcGisMapServerImageryProvider({\n                            url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer",\n                          }),\n                          terrainProvider: new Cesium.CesiumTerrainProvider({\n                            //加载火星在线地形\n                            url: "http://data.marsgis.cn/terrain",\n                          }),\n                          shouldAnimate: true,\n                          infoBox: false,\n                          selectionIndicator: false,\n                        });\n                        //设置贴地效果\n                        this.viewer.scene.globe.depthTestAgainstTerrain = false;\n                        //设置贴地效果 是否开启深度检测\n                        // this.viewer.scene.globe.depthTestAgainstTerrain = false;\n                        this.viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //循环结束\n                        this.viewer.clock.multiplier = 1;\n                        // this.viewer.clock.shouldAnimate = true;\n                        this._Entity = new Entity(Cesium, this.viewer);\n                        this._Primitives = new Primitives(Cesium, this.viewer);\n                        this.start();\n                      },\n                      /**\n                       * 开始\n                       */\n                      start() {\n                        const Cesium = this.cesium;\n                        // 创建模型 start\n                        const createModel = this._Entity.createModel({\n                          position: Cesium.Cartesian3.fromDegrees(\n                            123.42083739746174,\n                            41.814722258554795,\n                            1000.0\n                          ),\n                          //控制位偏移\n                          // viewFrom: new Cesium.Cartesian3(-100.0, 0.0, 100.0),\n                          uri: "/glb/Cesium_Air.glb",\n                          minimumPixelSize: 100,\n                        });\n                        // 创建模型 end\n                  \n                        //相机当前正在跟踪的Entity实例\n                        this.viewer.trackedEntity = createModel;\n                  \n                        //相机操作\n                        // this.viewer.flyTo(createModel, {\n                        //   duration: 3,\n                        // });\n                        this.viewer.camera.setView({\n                          //setView是直接跳到 flyTo// 是镜头飞行到  网速不好或者电脑配置不高 还是不要fly了吧\n                          destination: Cesium.Cartesian3.fromDegrees(\n                            123.42083739746174,\n                            41.814722258554795,\n                            1200.0\n                          ), //经纬度坐标转换为 笛卡尔坐标(世界坐标)\n                          //欧拉角\n                          orientation: {\n                            heading: Cesium.Math.toRadians(0.0), // east, default value is 0.0 (north) //东西南北朝向\n                            pitch: Cesium.Math.toRadians(-90.0), // default value (looking down)  //俯视仰视视觉\n                            roll: 0.0, // default value\n                          },\n                          duration: 3, //3秒到达战场\n                        });\n                  \n                        // computeEmitterModelMatrix 方法使用 start\n                        var emitterModelMatrix = new Cesium.Matrix4();\n                        var translation = new Cesium.Cartesian3();\n                        var rotation = new Cesium.Quaternion();\n                        var hpr = new Cesium.HeadingPitchRoll();\n                        var trs = new Cesium.TranslationRotationScale();\n                        // computeEmitterModelMatrix 方法使用 end\n                        var gravityScratch = new Cesium.Cartesian3();\n                  \n                        const methodsRight = {\n                          /**\n                           * 计算当前时间点飞机模型的位置矩阵\n                           * @param {*} entity 模型\n                           * @param {*} time\n                           */\n                          computeModelMatrix: (entity, time) => {\n                            return entity.computeModelMatrix(time, new Cesium.Matrix4());\n                          },\n                          /**\n                           * 计算引擎(粒子发射器)位置矩阵\n                           * 控制粒子发射的方向\n                           */\n                          computeEmitterModelMatrix: () => {\n                            /**\n                             * Cesium.HeadingPitchRoll.fromDegrees(0.0, 0.0, 0, hpr)\n                             * 旋转表示为航向，俯仰和横滚。标题是围绕负Z轴。节距是绕负y轴的旋转。滚动是关于正x轴。\n                             * 参数：\n                             * heading/弧度的航向分量。\n                             * pitch/弧度的螺距分量\n                             * Number/滚动分量（以弧度为单位）\n                             */\n                            hpr = Cesium.HeadingPitchRoll.fromDegrees(90.0, 0.0, 90.0, hpr);\n                            /**\n                             *  Cesium.Cartesian3.fromElements (x, y, z, result )\n                             * 根据x，y和z坐标创建Cartesian3实例。\n                             * x/x坐标。\n                             * y/y坐标。\n                             * z/z坐标。\n                             * result/将结果存储到的对象。\n                             */\n                            trs.translation = Cesium.Cartesian3.fromElements(\n                              -3,\n                              -3.5,\n                              0.5,\n                              translation\n                            );\n                            /**\n                             *  Cesium.Quaternion.fromHeadingPitchRoll (headingPitchRoll, result )\n                             * 根据给定的航向，俯仰和横滚角计算旋转角度。标题是围绕负Z轴。节距是绕负y轴的旋转。滚动是关于正x轴。\n                             * headingPitchRoll/旋转表示为航向，俯仰和横滚\n                             * result/将结果存储到的对象。\n                             */\n                            trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr, rotation);\n                            /**\n                             * 一个4x4矩阵，可索引为列主序数组。构造函数参数按行顺序排列，以提高代码的可读性。\n                             */\n                            return Cesium.Matrix4.fromTranslationRotationScale(\n                              trs,\n                              emitterModelMatrix\n                            );\n                          },\n                        };\n                        const methodsLeft = {\n                          /**\n                           * 计算当前时间点飞机模型的位置矩阵\n                           * @param {*} entity 模型\n                           * @param {*} time\n                           */\n                          computeModelMatrix: (entity, time) => {\n                            return entity.computeModelMatrix(time, new Cesium.Matrix4());\n                          },\n                          /**\n                           * 计算引擎(粒子发射器)位置矩阵\n                           * 控制粒子发射的方向\n                           */\n                          computeEmitterModelMatrix: () => {\n                            /**\n                             * Cesium.HeadingPitchRoll.fromDegrees(0.0, 0.0, 0, hpr)\n                             * 旋转表示为航向，俯仰和横滚。标题是围绕负Z轴。节距是绕负y轴的旋转。滚动是关于正x轴。\n                             * 参数：\n                             * heading/弧度的航向分量。\n                             * pitch/弧度的螺距分量\n                             * Number/滚动分量（以弧度为单位）\n                             */\n                            hpr = Cesium.HeadingPitchRoll.fromDegrees(90.0, 0.0, 90.0, hpr);\n                            /**\n                             *  Cesium.Cartesian3.fromElements (x, y, z, result )\n                             * 根据x，y和z坐标创建Cartesian3实例。\n                             * x/x坐标。\n                             * y/y坐标。\n                             * z/z坐标。\n                             * result/将结果存储到的对象。\n                             */\n                            trs.translation = Cesium.Cartesian3.fromElements(\n                              -3,\n                              3.5,\n                              0.5,\n                              translation\n                            );\n                            /**\n                             *  Cesium.Quaternion.fromHeadingPitchRoll (headingPitchRoll, result )\n                             * 根据给定的航向，俯仰和横滚角计算旋转角度。标题是围绕负Z轴。节距是绕负y轴的旋转。滚动是关于正x轴。\n                             * headingPitchRoll/旋转表示为航向，俯仰和横滚\n                             * result/将结果存储到的对象。\n                             */\n                            trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr, rotation);\n                            /**\n                             * 一个4x4矩阵，可索引为列主序数组。构造函数参数按行顺序排列，以提高代码的可读性。\n                             */\n                            return Cesium.Matrix4.fromTranslationRotationScale(\n                              trs,\n                              emitterModelMatrix\n                            );\n                          },\n                        };\n                        //创建粒子 start\n                        //通用的配置\n                        const CommonConfig = {\n                          image: "/image/fire.png",\n                          /**\n                           * 每帧都要调用一次回调函数以更新粒子。\n                           * @param {*} particle 正在更新粒子。\n                           * @param {*} dt 自上次更新以来的时间（秒）\n                           * 重力\n                           */\n                          updateCallback: (particle, dt) => {\n                            var position = particle.position;\n                            Cesium.Cartesian3.normalize(position, gravityScratch);\n                            Cesium.Cartesian3.multiplyByScalar(\n                              gravityScratch,\n                              0 * dt,\n                              gravityScratch\n                            );\n                            particle.velocity = Cesium.Cartesian3.add(\n                              particle.velocity,\n                              gravityScratch,\n                              particle.velocity\n                            );\n                          },\n                          //模型\n                          entity: createModel,\n                          startColor: Cesium.Color.LIGHTSEAGREEN.withAlpha(0.7),\n                          endColor: Cesium.Color.WHITE.withAlpha(0.0),\n                          startScale: 1,\n                          endScale: 10,\n                          particleLife: 1,\n                          minimumParticleLife: 0.1,\n                          maximumParticleLife: 0.2,\n                          minimumSpeed: 3,\n                          maximumSpeed: 2,\n                          imageSize: new Cesium.Cartesian2(3, 3),\n                          emissionRate: 30,\n                          bursts: [\n                            new Cesium.ParticleBurst({\n                              time: 0.1,\n                              minimum: 10,\n                              maximum: 50,\n                            }),\n                            new Cesium.ParticleBurst({\n                              time: 0.2,\n                              minimum: 20,\n                              maximum: 50,\n                            }),\n                            new Cesium.ParticleBurst({\n                              time: 0.3,\n                              minimum: 50,\n                              maximum: 100,\n                            }),\n                          ],\n                          lifetime: 0.4,\n                          emitter: new Cesium.CircleEmitter(0.5),\n                          modelMatrix: () => {\n                            return createModel.computeModelMatrix(\n                              Cesium.JulianDate.now(),\n                              new Cesium.Matrix4()\n                            );\n                          },\n                        };\n                        const createParticleSystemRight = this._Primitives.createParticleSystem({\n                          emitterModelMatrix: methodsRight.computeEmitterModelMatrix(),\n                          ...CommonConfig,\n                        });\n                        const createParticleSystemLeft = this._Primitives.createParticleSystem({\n                          emitterModelMatrix: methodsLeft.computeEmitterModelMatrix(),\n                          ...CommonConfig,\n                        });\n                        //创建粒子 end\n                  \n                        //获取在更新或渲染场景之前将引发的事件。活动订阅者将Scene实例作为第一个参数，将当前时间作为第二个参数。\n                        this.viewer.scene.preUpdate.addEventListener((scene, time) => {\n                          createParticleSystemRight.modelMatrix = methodsRight.computeModelMatrix(\n                            createModel,\n                            time\n                          );\n                          // 说明对发射器模型矩阵的任何更改\n                          createParticleSystemRight.emitterModelMatrix =\n                            methodsRight.computeEmitterModelMatrix();\n                          /////////////////\n                          createParticleSystemLeft.modelMatrix = methodsLeft.computeModelMatrix(\n                            createModel,\n                            time\n                          );\n                          // 说明对发射器模型矩阵的任何更改\n                          createParticleSystemLeft.emitterModelMatrix =\n                            methodsLeft.computeEmitterModelMatrix();\n                        });\n                      },\n                    },\n                  };'},{codeLanguage:"css",content:".container {\n                    width: 100%;\n                    height: 100%;\n                    #cesiumContainer {\n                      width: 100%;\n                      height: 100%;\n                    }\n                  }"}]},{codeLanguage:"JS",relyOn:[{label:"Primitives.js",url:"JavaScript/cesium/Primitives.js"},{label:"Entity.js",url:"JavaScript/cesium/Entity.js"},{label:"Cesium_Air.glb",url:"JavaScript/Primitives/ParticleSystem/AircraftTailFlame/Cesium_Air.glb"},{label:"fire.png",url:"JavaScript/Primitives/ParticleSystem/AircraftTailFlame/fire.png"}],code:[{codeLanguage:"js",content:'function openAircraftFlame() {\n                      viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //循环结束\n                      viewer.clock.multiplier = 1;\n                      viewer.clock.shouldAnimate = true;\n                  \n                      // 创建模型 start\n                      const _Entity = new Entity(Cesium, viewer);\n                      const createModel = _Entity.createModel({\n                          position: Cesium.Cartesian3.fromDegrees(\n                              123.42083739746174,\n                              41.814722258554795,\n                              1000.0\n                          ),\n                          //控制位偏移\n                          // viewFrom: new Cesium.Cartesian3(-100.0, 0.0, 100.0),\n                          uri: "http://192.168.0.32:8088/Cesium_Air.glb",\n                          minimumPixelSize: 100,\n                      });\n                      // 创建模型 end\n                  \n                      //相机当前正在跟踪的Entity实例\n                      viewer.trackedEntity = createModel;\n                  \n                      //相机\n                      viewer.camera.setView({\n                          //setView是直接跳到 flyTo// 是镜头飞行到  网速不好或者电脑配置不高 还是不要fly了吧\n                          destination: Cesium.Cartesian3.fromDegrees(\n                              123.42083739746174,\n                              41.814722258554795,\n                              1200.0\n                          ), //经纬度坐标转换为 笛卡尔坐标(世界坐标)\n                          //欧拉角\n                          orientation: {\n                              heading: Cesium.Math.toRadians(0.0), // east, default value is 0.0 (north) //东西南北朝向\n                              pitch: Cesium.Math.toRadians(-90.0), // default value (looking down)  //俯视仰视视觉\n                              roll: 0.0, // default value\n                          },\n                          duration: 3, //3秒到达战场\n                      });\n                  \n                  \n                      // computeEmitterModelMatrix 方法使用 start\n                      var emitterModelMatrix = new Cesium.Matrix4();\n                      var translation = new Cesium.Cartesian3();\n                      var rotation = new Cesium.Quaternion();\n                      var hpr = new Cesium.HeadingPitchRoll();\n                      var trs = new Cesium.TranslationRotationScale();\n                      // computeEmitterModelMatrix 方法使用 end\n                      var gravityScratch = new Cesium.Cartesian3();\n                  \n                      const methodsRight = {\n                          /**\n                           * 计算当前时间点飞机模型的位置矩阵\n                           * @param {*} entity 模型\n                           * @param {*} time\n                           */\n                          computeModelMatrix: (entity, time) => {\n                              return entity.computeModelMatrix(time, new Cesium.Matrix4());\n                          },\n                          /**\n                           * 计算引擎(粒子发射器)位置矩阵\n                           * 控制粒子发射的方向\n                           */\n                          computeEmitterModelMatrix: () => {\n                              /**\n                               * Cesium.HeadingPitchRoll.fromDegrees(0.0, 0.0, 0, hpr)\n                               * 旋转表示为航向，俯仰和横滚。标题是围绕负Z轴。节距是绕负y轴的旋转。滚动是关于正x轴。\n                               * 参数：\n                               * heading/弧度的航向分量。\n                               * pitch/弧度的螺距分量\n                               * Number/滚动分量（以弧度为单位）\n                               */\n                              hpr = Cesium.HeadingPitchRoll.fromDegrees(90.0, 0.0, 90.0, hpr);\n                              /**\n                               *  Cesium.Cartesian3.fromElements (x, y, z, result )\n                               * 根据x，y和z坐标创建Cartesian3实例。\n                               * x/x坐标。\n                               * y/y坐标。\n                               * z/z坐标。\n                               * result/将结果存储到的对象。\n                               */\n                              trs.translation = Cesium.Cartesian3.fromElements(\n                                  -3,\n                                  -3.5,\n                                  0.5,\n                                  translation\n                              );\n                              /**\n                               *  Cesium.Quaternion.fromHeadingPitchRoll (headingPitchRoll, result )\n                               * 根据给定的航向，俯仰和横滚角计算旋转角度。标题是围绕负Z轴。节距是绕负y轴的旋转。滚动是关于正x轴。\n                               * headingPitchRoll/旋转表示为航向，俯仰和横滚\n                               * result/将结果存储到的对象。\n                               */\n                              trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr, rotation);\n                              /**\n                               * 一个4x4矩阵，可索引为列主序数组。构造函数参数按行顺序排列，以提高代码的可读性。\n                               */\n                              return Cesium.Matrix4.fromTranslationRotationScale(\n                                  trs,\n                                  emitterModelMatrix\n                              );\n                          },\n                      };\n                      const methodsLeft = {\n                          /**\n                           * 计算当前时间点飞机模型的位置矩阵\n                           * @param {*} entity 模型\n                           * @param {*} time\n                           */\n                          computeModelMatrix: (entity, time) => {\n                              return entity.computeModelMatrix(time, new Cesium.Matrix4());\n                          },\n                          /**\n                           * 计算引擎(粒子发射器)位置矩阵\n                           * 控制粒子发射的方向\n                           */\n                          computeEmitterModelMatrix: () => {\n                              /**\n                               * Cesium.HeadingPitchRoll.fromDegrees(0.0, 0.0, 0, hpr)\n                               * 旋转表示为航向，俯仰和横滚。标题是围绕负Z轴。节距是绕负y轴的旋转。滚动是关于正x轴。\n                               * 参数：\n                               * heading/弧度的航向分量。\n                               * pitch/弧度的螺距分量\n                               * Number/滚动分量（以弧度为单位）\n                               */\n                              hpr = Cesium.HeadingPitchRoll.fromDegrees(90.0, 0.0, 90.0, hpr);\n                              /**\n                               *  Cesium.Cartesian3.fromElements (x, y, z, result )\n                               * 根据x，y和z坐标创建Cartesian3实例。\n                               * x/x坐标。\n                               * y/y坐标。\n                               * z/z坐标。\n                               * result/将结果存储到的对象。\n                               */\n                              trs.translation = Cesium.Cartesian3.fromElements(\n                                  -3,\n                                  3.5,\n                                  0.5,\n                                  translation\n                              );\n                              /**\n                               *  Cesium.Quaternion.fromHeadingPitchRoll (headingPitchRoll, result )\n                               * 根据给定的航向，俯仰和横滚角计算旋转角度。标题是围绕负Z轴。节距是绕负y轴的旋转。滚动是关于正x轴。\n                               * headingPitchRoll/旋转表示为航向，俯仰和横滚\n                               * result/将结果存储到的对象。\n                               */\n                              trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr, rotation);\n                              /**\n                               * 一个4x4矩阵，可索引为列主序数组。构造函数参数按行顺序排列，以提高代码的可读性。\n                               */\n                              return Cesium.Matrix4.fromTranslationRotationScale(\n                                  trs,\n                                  emitterModelMatrix\n                              );\n                          },\n                      };\n                  \n                      //创建粒子 start\n                      const _Primitives = new Primitives(Cesium, this.viewer);\n                      //通用的配置\n                      const CommonConfig = {\n                          image: "../images/test/fire.png",\n                          /**\n                           * 每帧都要调用一次回调函数以更新粒子。\n                           * @param {*} particle 正在更新粒子。\n                           * @param {*} dt 自上次更新以来的时间（秒）\n                           * 重力\n                           */\n                          updateCallback: (particle, dt) => {\n                              var position = particle.position;\n                              Cesium.Cartesian3.normalize(position, gravityScratch);\n                              Cesium.Cartesian3.multiplyByScalar(\n                                  gravityScratch,\n                                  0 * dt,\n                                  gravityScratch\n                              );\n                              particle.velocity = Cesium.Cartesian3.add(\n                                  particle.velocity,\n                                  gravityScratch,\n                                  particle.velocity\n                              );\n                          },\n                          //模型\n                          entity: createModel,\n                          startColor: Cesium.Color.LIGHTSEAGREEN.withAlpha(0.7),\n                          endColor: Cesium.Color.WHITE.withAlpha(0.0),\n                          startScale: 1,\n                          endScale: 10,\n                          particleLife: 1,\n                          minimumParticleLife: 0.1,\n                          maximumParticleLife: 0.2,\n                          minimumSpeed: 3,\n                          maximumSpeed: 2,\n                          imageSize: new Cesium.Cartesian2(3, 3),\n                          emissionRate: 30,\n                          bursts: [\n                              new Cesium.ParticleBurst({\n                                  time: 0.1,\n                                  minimum: 10,\n                                  maximum: 50,\n                              }),\n                              new Cesium.ParticleBurst({\n                                  time: 0.2,\n                                  minimum: 20,\n                                  maximum: 50,\n                              }),\n                              new Cesium.ParticleBurst({\n                                  time: 0.3,\n                                  minimum: 50,\n                                  maximum: 100,\n                              }),\n                          ],\n                          lifetime: 0.4,\n                          emitter: new Cesium.CircleEmitter(0.5),\n                          modelMatrix: () => {\n                              return createModel.computeModelMatrix(\n                                  Cesium.JulianDate.now(),\n                                  new Cesium.Matrix4()\n                              );\n                          },\n                      };\n                      const createParticleSystemRight = _Primitives.createParticleSystem({\n                          emitterModelMatrix: methodsRight.computeEmitterModelMatrix(),\n                          ...CommonConfig,\n                      });\n                      const createParticleSystemLeft = _Primitives.createParticleSystem({\n                          emitterModelMatrix: methodsLeft.computeEmitterModelMatrix(),\n                          ...CommonConfig,\n                      });\n                      //创建粒子 end\n                      //获取在更新或渲染场景之前将引发的事件。活动订阅者将Scene实例作为第一个参数，将当前时间作为第二个参数。\n                      this.viewer.scene.preUpdate.addEventListener(function (scene, time) {\n                          createParticleSystemRight.modelMatrix = methodsRight.computeModelMatrix(\n                              createModel,\n                              time\n                          );\n                          // 说明对发射器模型矩阵的任何更改\n                          createParticleSystemRight.emitterModelMatrix =\n                              methodsRight.computeEmitterModelMatrix();\n                          /////////////////\n                          createParticleSystemLeft.modelMatrix = methodsLeft.computeModelMatrix(\n                              createModel,\n                              time\n                          );\n                          // 说明对发射器模型矩阵的任何更改\n                          createParticleSystemLeft.emitterModelMatrix =\n                              methodsLeft.computeEmitterModelMatrix();\n                      });\n                  }\n                  //开始\n                  openAircraftFlame()\n                  '}]}],d={name:"AircraftTailFlame",data:function(){return{viewer:null,_Primitives:null,_Entity:null}},created:function(){this.$store.dispatch("highlight/set_code",u)},mounted:function(){this.init()},methods:{init:function(){var e=this.cesium;e.Ion.defaultAccessToken=Object({NODE_ENV:"production",VUE_APP_BASE_API:"/prod-api",VUE_APP_GAODE_KEY_WEB_SERVICE:"181ced609de9d446207b55e549bafcb6",VUE_APP_GAODE_KEY_WEB_TERMINAL:"cb250acd7ee0e7b2049cb93747ae3d44",VUE_APP_PUBLIC_URL:"/cesium-template",VUE_APP_SECURITY_JS_CODE:"2a0ce2005352672661417093c485a056",BASE_URL:""}).VUE_APP_TOKEN,this.viewer=new e.Viewer("cesiumContainer",{imageryProvider:new e.ArcGisMapServerImageryProvider({url:"https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"}),terrainProvider:new e.CesiumTerrainProvider({url:"http://data.marsgis.cn/terrain"}),shouldAnimate:!0,infoBox:!1,selectionIndicator:!1}),this.viewer.scene.globe.depthTestAgainstTerrain=!1,this.viewer.clock.clockRange=e.ClockRange.LOOP_STOP,this.viewer.clock.multiplier=1,this._Entity=new c["a"](e,this.viewer),this._Primitives=new l(e,this.viewer),this.start()},start:function(){var e=this.cesium,t=this._Entity.createModel({position:e.Cartesian3.fromDegrees(123.42083739746174,41.814722258554795,1e3),uri:"/cesium-template/glb/Cesium_Air.glb",minimumPixelSize:100});this.viewer.trackedEntity=t,this.viewer.camera.setView({destination:e.Cartesian3.fromDegrees(123.42083739746174,41.814722258554795,1200),orientation:{heading:e.Math.toRadians(0),pitch:e.Math.toRadians(-90),roll:0},duration:3});var n=new e.Matrix4,i=new e.Cartesian3,r=new e.Quaternion,m=new e.HeadingPitchRoll,o=new e.TranslationRotationScale,s=new e.Cartesian3,l={computeModelMatrix:function(t,n){return t.computeModelMatrix(n,new e.Matrix4)},computeEmitterModelMatrix:function(){return m=e.HeadingPitchRoll.fromDegrees(90,0,90,m),o.translation=e.Cartesian3.fromElements(-3,-3.5,.5,i),o.rotation=e.Quaternion.fromHeadingPitchRoll(m,r),e.Matrix4.fromTranslationRotationScale(o,n)}},c={computeModelMatrix:function(t,n){return t.computeModelMatrix(n,new e.Matrix4)},computeEmitterModelMatrix:function(){return m=e.HeadingPitchRoll.fromDegrees(90,0,90,m),o.translation=e.Cartesian3.fromElements(-3,3.5,.5,i),o.rotation=e.Quaternion.fromHeadingPitchRoll(m,r),e.Matrix4.fromTranslationRotationScale(o,n)}},u={image:"/cesium-template/image/fire.png",updateCallback:function(t,n){var i=t.position;e.Cartesian3.normalize(i,s),e.Cartesian3.multiplyByScalar(s,0*n,s),t.velocity=e.Cartesian3.add(t.velocity,s,t.velocity)},entity:t,startColor:e.Color.LIGHTSEAGREEN.withAlpha(.7),endColor:e.Color.WHITE.withAlpha(0),startScale:1,endScale:10,particleLife:1,minimumParticleLife:.1,maximumParticleLife:.2,minimumSpeed:3,maximumSpeed:2,imageSize:new e.Cartesian2(3,3),emissionRate:30,bursts:[new e.ParticleBurst({time:.1,minimum:10,maximum:50}),new e.ParticleBurst({time:.2,minimum:20,maximum:50}),new e.ParticleBurst({time:.3,minimum:50,maximum:100})],lifetime:.4,emitter:new e.CircleEmitter(.5),modelMatrix:function(){return t.computeModelMatrix(e.JulianDate.now(),new e.Matrix4)}},d=this._Primitives.createParticleSystem(Object(a["a"])({emitterModelMatrix:l.computeEmitterModelMatrix()},u)),h=this._Primitives.createParticleSystem(Object(a["a"])({emitterModelMatrix:c.computeEmitterModelMatrix()},u));this.viewer.scene.preUpdate.addEventListener((function(e,n){d.modelMatrix=l.computeModelMatrix(t,n),d.emitterModelMatrix=l.computeEmitterModelMatrix(),h.modelMatrix=c.computeModelMatrix(t,n),h.emitterModelMatrix=c.computeEmitterModelMatrix()}))}}},h=d,M=(n("bfe5"),n("cba8")),C=Object(M["a"])(h,i,r,!1,null,"71b0c793",null);t["default"]=C.exports}}]);